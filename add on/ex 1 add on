# Add-On: Single-Layer Perceptron for XOR

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import Perceptron

X = np.array([[0,0],[0,1],[1,0],[1,1]])
y = np.array([0,1,1,0])

clf = Perceptron(tol=1e-3, random_state=0)
clf.fit(X, y)

print("üîπ Perceptron Predictions:")
for i in range(len(X)):
    print(f"Input: {X[i]} ‚Üí Predicted: {clf.predict([X[i]])[0]} | Expected: {y[i]}")

for i in range(len(X)):
    if y[i] == 0:
        plt.scatter(X[i][0], X[i][1], color='red', label="Class 0" if i==0 else "")
    else:
        plt.scatter(X[i][0], X[i][1], color='blue', label="Class 1" if i==1 else "")

# Decision boundary (only works if perceptron finds linear separation)
x_values = [0, 1]
try:
    y_values = -(clf.coef_[0][0]*np.array(x_values) + clf.intercept_)/clf.coef_[0][1]
    plt.plot(x_values, y_values, color='green', label="Decision Boundary")
except:
    print("‚ö†Ô∏è Perceptron could not find a valid decision boundary.")

plt.title('Perceptron Decision Boundary for XOR')
plt.legend()
plt.show()




output:
üîπ Perceptron Predictions:
Input: [0 0] ‚Üí Predicted: 0 | Expected: 0
Input: [0 1] ‚Üí Predicted: 0 | Expected: 1
Input: [1 0] ‚Üí Predicted: 0 | Expected: 1
Input: [1 1] ‚Üí Predicted: 0 | Expected: 0
/tmp/ipython-input-2684219932.py:38: RuntimeWarning: invalid value encountered in divide
  y_values = -(clf.coef_[0][0]*np.array(x_values) + clf.intercept_)/clf.coef_[0][1]
